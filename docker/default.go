package docker

import (
	"errors"
	"fmt"
	"gitlab.com/gitlab-red-team/private-research/cve-2021-22205-hash-generator/tags"
	"os/exec"
	"regexp"
	"strings"
)

type Command struct {
	Cmd string
	Args []string
}

func (c *Command) string() string {
	return fmt.Sprintf("%s %s", c.Cmd, fmt.Sprintf(strings.Join(c.Args[:], " ")))
}

func (c *Command) execute() ([]byte, *exec.ExitError) {
	cmd := exec.Command(c.Cmd, c.Args...)
	stdOut, err := cmd.Output()
	var exitErr *exec.ExitError
	if errors.As(err, &exitErr) {
		return []byte{}, exitErr
	}
	return stdOut, nil
}

func GetHashFromStdOut(stdOut []byte) string {
	hashRegex := regexp.MustCompile(`(?:application-)(\S{64})(?:\.css.gz)`)
	result := hashRegex.FindStringSubmatch(fmt.Sprintf("%s", stdOut))
	return fmt.Sprintf("%s", result[1]) //bail if no result is found.  there should always be a application-*.css file packaged in the image.
}

func ExecuteRunCommand(tag tags.Tag) (string, *exec.ExitError) {
	runCmd := Command{
		Cmd:  "docker",
		Args: []string{"run", "--rm", "-i", "--entrypoint", "ls", tag.ImageFull(), "/opt/gitlab/embedded/service/gitlab-rails/public/assets" },
	}
	fmt.Printf("Executing: %s\n", runCmd.string())
	runCmdResult, exitErr := runCmd.execute()
	if exitErr != nil {
		return "", exitErr
	}
	return GetHashFromStdOut(runCmdResult), nil
}

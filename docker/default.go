package docker

import (
	"errors"
	"fmt"
	"gitlab.com/gitlab-red-team/private-research/cve-2021-22205-hash-generator/tags"
	"os/exec"
	"regexp"
	"strings"
)

type Command struct {
	Cmd string
	Args []string
}

func (c *Command) string() string {
	return fmt.Sprintf("%s %s", c.Cmd, fmt.Sprintf(strings.Join(c.Args[:], " ")))
}

func (c *Command) execute() tags.Tag {
	cmd := exec.Command(c.Cmd, c.Args...)
	stdOut, err := cmd.Output()
	var exitErr *exec.ExitError
	if errors.As(err, &exitErr) {
		return tags.Tag{CmdResult: "", ExitError: exitErr}
	}
	return tags.Tag{CmdResult: string(stdOut), ExitError: nil}
}

func GetHashFromStdOut(stdOut string) string {
	if len(stdOut) == 0 {
		return ""
	}
	hashRegex := regexp.MustCompile(`(?:application-)(\S{64})(?:\.css.gz)`)
	result := hashRegex.FindStringSubmatch(fmt.Sprintf("%s", stdOut))
	return fmt.Sprintf("%s", result[1]) //bail if no result is found.  there should always be an application-*.css file packaged in the image.
}

func ExecuteRunCommand(tag tags.Tag) <- chan tags.Tag {
	r := make(chan tags.Tag)
	go func() {
		defer close(r)
		runCmd := Command{
			Cmd:  "docker",
			Args: []string{"run", "--rm", "-i", "--entrypoint", "ls", tag.Name, "/opt/gitlab/embedded/service/gitlab-rails/public/assets" },
		}
		fmt.Printf("[*] Executing: %s\n", runCmd.string())
		tag := runCmd.execute()
		tag.CmdResult = GetHashFromStdOut(tag.CmdResult)
		r <- tag
	}()
	return r
}

func ExecuteImageRemove(tag tags.Tag) <- chan tags.Tag {
	r := make(chan tags.Tag)
	go func() {
		defer close(r)
		rmCmd := Command{
			Cmd: "docker",
			Args: []string{"image", "rm", "-f", tag.Name},
		}
		fmt.Printf("Executing: %s\n", rmCmd.string())
		r <- rmCmd.execute()
	}()
	return r
}

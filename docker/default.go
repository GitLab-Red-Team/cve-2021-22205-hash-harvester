package docker

import (
	"errors"
	"fmt"
	"gitlab.com/gitlab-red-team/private-research/cve-2021-22205-hash-generator/tags"
	"os/exec"
	"regexp"
	"strings"
)

type Command struct {
	Cmd  string
	Args []string
}

func (c *Command) string() string {
	args := fmt.Sprint(strings.Join(c.Args[:], " "))
	return fmt.Sprintf("%s %s", c.Cmd, args)
}

func (c *Command) execute(tag *tags.Tag) {
	cmd := exec.Command(c.Cmd, c.Args...)
	stdOut, err := cmd.Output()
	var exitErr *exec.ExitError
	if errors.As(err, &exitErr) {
		tag.StdOut = ""
		tag.ExitError = exitErr
		return
	}
	tag.StdOut = string(stdOut)
	tag.ExitError = nil
}

func GetHashFromStdOut(stdOut string) string {
	if len(stdOut) == 0 {
		return ""
	}
	hashRegex := regexp.MustCompile(`(?:application-)(\S{64})(?:\.css.gz)`)
	result := hashRegex.FindStringSubmatch(stdOut)
	return result[1] //bail if no result is found.  there should always be an application-*.css file packaged in the image.
}

func ExecuteRunCommand(tag *tags.Tag) {
	runCmd := Command{
		Cmd:  "docker",
		Args: []string{"run", "--rm", "-i", "--entrypoint", "ls", tag.Name, "/opt/gitlab/embedded/service/gitlab-rails/public/assets"},
	}
	fmt.Printf("[*] Executing: %s\n", runCmd.string())
	runCmd.execute(tag)
	tag.Hash = GetHashFromStdOut(tag.StdOut)
}

func ExecuteImageRemove(tag *tags.Tag) {
	rmCmd := Command{
		Cmd:  "docker",
		Args: []string{"image", "rm", "-f", tag.Name},
	}
	fmt.Printf("[*] Executing: %s\n", rmCmd.string())
	rmCmd.execute(tag)
}

package docker

import (
	"errors"
	"fmt"
	"gitlab.com/gitlab-red-team/private-research/cve-2021-22205-hash-generator/tags"
	"os/exec"
	"regexp"
	"strings"
)

type Command struct {
	Cmd  string
	Args []string
}

func (c *Command) string() string {
	return fmt.Sprintf("%s %s", c.Cmd, fmt.Sprintf(strings.Join(c.Args[:], " ")))
}

func (c *Command) execute() tags.Tag {
	cmd := exec.Command(c.Cmd, c.Args...)
	stdOut, err := cmd.Output()
	var exitErr *exec.ExitError
	if errors.As(err, &exitErr) {
		return tags.Tag{StdOut: "", ExitError: exitErr}
	}
	return tags.Tag{StdOut: string(stdOut), ExitError: nil}
}

func GetHashFromStdOut(stdOut string) string {
	if len(stdOut) == 0 {
		return ""
	}
	hashRegex := regexp.MustCompile(`(?:application-)(\S{64})(?:\.css.gz)`)
	result := hashRegex.FindStringSubmatch(fmt.Sprintf("%s", stdOut))
	return fmt.Sprintf("%s", result[1]) //bail if no result is found.  there should always be an application-*.css file packaged in the image.
}

func ExecuteRunCommand(tag tags.Tag) tags.Tag {
	runCmd := Command{
		Cmd:  "docker",
		Args: []string{"run", "--rm", "-i", "--entrypoint", "ls", tag.Name, "/opt/gitlab/embedded/service/gitlab-rails/public/assets"},
	}
	fmt.Printf("[*] Executing: %s\n", runCmd.string())
	t := runCmd.execute()
	t.Hash = GetHashFromStdOut(tag.StdOut)
	return tag
}

func ExecuteImageRemove(tag tags.Tag) tags.Tag {
	rmCmd := Command{
		Cmd:  "docker",
		Args: []string{"image", "rm", "-f", tag.Name},
	}
	fmt.Printf("Executing: %s\n", rmCmd.string())
	return rmCmd.execute()
}
